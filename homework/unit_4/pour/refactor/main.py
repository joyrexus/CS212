from collections import namedtuple as named
from search import shortest_path as search

Glass = named('Glass', 'level, total')


class State(named('State', 'glasses, action')):
    __slots__ = ()
    def contains(self, goal):
        return any(glass.level == goal for glass in self.glasses)


class Glasses(tuple):
    '''
    Tuple-based representation of glasses.

    '''
    def __new__(cls, seq): 
        return tuple.__new__(cls, seq) 

    def fill(self, i):
        '''
        Fill glass with index i to capacity and 
        return new state of glasses.
    
        '''
        state = list(self)
        total = state[i].total
        state[i] = Glass(total, total)
        return Glasses(state)

    def empty(self, i):
        '''
        Empty glass with index i and return new
        state of glasses.

        '''
        state = list(self)
        state[i] = Glass(0, state[i].total)
        return Glasses(state)

    def pour(self, i, j):
        '''
        Pour from glass with index i to glass with index j.
        
        Return new state of glasses.

        '''
        state = list(self)
        I, J = state[i], state[j]
        if I.level + J.level < J.total:
            state[i] = Glass(0, I.total)
            state[j] = Glass(I.level + J.level, J.total)
        else:
            delta = (J.total - J.level)
            state[i] = Glass(I.level - delta, I.total)
            state[j] = Glass(J.level + delta, J.total)
        return Glasses(state)


def next(state):
    next = []
    glasses = state.glasses
    indices = range(len(glasses))
    for i in indices:
        next.append(State(glasses.fill(i), action=('fill',i)))
        next.append(State(glasses.empty(i), action=('empty',i)))
        for j in indices:
            if i == j: continue
            next.append(State(glasses.pour(i,j), action=('pour',i,j)))
    return set(next)

def solve(totals, goal, init=None):
    '''
    Search for shortest path to solve the pouring problem.

    totals -- a tuple of capacities (numbers) of glasses

    goal -- a number indicating the volume level we want 
            to have any one of the glasses contain

    init -- optional tuple of initial levels for each glass

    If start is not specified, we set the starting levels of each 
    glass to zero.

    We start the search at the start state and follow paths of 
    successor states (generated by `next`) until we reach the goal.

    After reaching the goal state, we return the shortest path
    found, a sequence of states from start to goal state.

    '''
    done = lambda state: state.contains(goal)
    init = init or tuple(0 for t in totals)
    glasses = (Glass(i,t) for i,t in zip(init, totals))
    start = State(Glasses(glasses), action=None)
    return search(start, next, done)
    

if __name__ == '__main__':

    g = Glass(0, 5)
    assert g.level == 0
    assert g.total == 5

    glasses = Glasses([Glass(3,5), Glass(0,10)])
    assert glasses.empty(0) == (Glass(0,5), Glass(0,10))
    assert glasses.fill(1) == (Glass(3,5), Glass(10,10))
    assert glasses.pour(0,1) == (Glass(0,5), Glass(3,10))

    state = State(glasses, action=None)
    assert state.contains(3)
    assert state.contains(0)
    assert not state.contains(1)

    start = State(Glasses([Glass(0,1), 
                           Glass(0,2), 
                           Glass(0,4),
                           Glass(0,8)]), action=None)

    stop = State(Glasses([Glass(0,1), 
                          Glass(0,2), 
                          Glass(4,4),
                          Glass(0,8)]), action=('fill', 2))

    assert stop.contains(4)
    assert solve(totals=(1,2,4,8), goal=4) == [start, stop]
